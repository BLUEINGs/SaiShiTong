# Java Web Controller层各种请求方式的处理

---

#### **请求参数接收方式总结表**

| **请求方式** | **数据格式**                    | **适用场景**               | **注解使用**              | **示例 POJO 类**                     |
|--------------|---------------------------------|--------------------------|--------------------------|--------------------------------------|
| `GET`        | URL 参数（`?key=value`）        | 简单查询、删除操作       | **无需注解**             | `SchoolDeleteRequest`                |
| `POST`       | `application/json`              | 复杂对象、嵌套结构       | `@RequestBody` + POJO    | `SportGroupAddRequest`               |
| `POST`       | `multipart/form-data`           | 文件上传 + 表单数据      | `@ModelAttribute` + POJO | `SchoolModifyRequest`（含文件字段）  |
| `POST`       | `x-www-form-urlencoded`         | 简单键值对（无文件）     | **无需注解**             | `ScoreAddRequest`                    |

---

### **详细说明与示例**

---

#### **1. GET 请求（URL 参数）**
- **场景**：通过 URL 参数传递简单数据（如 `/deleteSchool?scId=1&name=第一中学`）。
- **POJO 类定义**：
  ```java
  @Data //自动给setter和getter方法
  @NoArgsConstructor  //自动给无参构造
  @AllArgsConstructor //自动给全参构造
  public class SchoolDeleteRequest {
      private Integer scId;  // 字段名必须与 URL 参数键名完全一致
      private String name;
  }
  ```
- **Controller 接收方式**：
  ```java
  @GetMapping("/deleteSchool")
  public Result deleteSchool(SchoolDeleteRequest request) {  // 直接绑定到 POJO
      if (request.getScId() == null) {
          return Result.fail("scId 不能为空");
      }
      // 业务逻辑
  }
  ```
- **关键点**：  
  - 字段名必须与 URL 参数键名完全一致（包括大小写）。  
  - 无需使用 `@RequestParam`，Spring 自动完成绑定。

---

#### **2. POST 请求（JSON 格式）**
- **场景**：传递复杂嵌套数据（如添加赛程组）。
- **请求体示例**：
  ```json
  {
      "name": "200米跑赛组",
      "compSystem": 3,
      "sports": [ { "spId": 101 } ]
  }
  ```
- **POJO 类定义**：
  ```java
  public class SportGroupAddRequest {
      private String name;
      private Integer compSystem;
      private List<SportDetail> sports;  // 嵌套对象

      public static class SportDetail {
          private Integer spId;  // 嵌套字段名与 JSON 键名一致
      }
  }
  ```
- **Controller 接收方式**：
  ```java
  @PostMapping("/addSport")
  public Result addSport(@RequestBody SportGroupAddRequest request) {  // 必须加 @RequestBody
      if (request.getSports() == null || request.getSports().isEmpty()) {
          return Result.fail("sports 不能为空");
      }
      // 业务逻辑
  }
  ```
- **关键点**：  
  - 必须使用 `@RequestBody` 注解，Spring 将 JSON 反序列化为 POJO。  
  - 嵌套字段需定义静态内部类。

---

#### **3. POST 请求（multipart/form-data）**
- **场景**：文件上传 + 表单字段混合提交（如修改学校信息并上传 Logo）。
- **POJO 类定义**：
  ```java
  public class SchoolModifyRequest {
      private Integer scId;         // 学校ID
      private String name;          // 学校名称
      private String slogan;        // 学校口号
      private MultipartFile img;    // 文件字段（字段名与表单一致）
  }
  ```
- **Controller 接收方式**：
  ```java
  @PostMapping("/modifySchool")
  public Result modifySchool(@ModelAttribute SchoolModifyRequest request) {  // 必须加 @ModelAttribute
      if (request.getImg().isEmpty()) {
          return Result.fail("文件不能为空");
      }
      // 保存文件并更新学校信息
  }
  ```
- **关键点**：  
  - **必须使用 `@ModelAttribute`**，Spring 将表单数据和文件绑定到 POJO。  
  - 文件字段类型为 `MultipartFile`，需判空处理。

---

#### **4. POST 请求（x-www-form-urlencoded）**
- **场景**：简单键值对提交（如录入成绩）。
- **POJO 类定义**：
  ```java
  public class ScoreAddRequest {
      private Integer spId;    // 运动项目ID
      private Integer pId;     // 运动员ID
      private Double score;    // 成绩（包装类）
      private String source;   // 来源（如 "手动录入"）
      private String degree;   // 等级（如 "A级"）
  }
  ```
- **Controller 接收方式**：
  ```java
  @PostMapping("/addScore")
  public Result addScore(ScoreAddRequest request) {  // 直接绑定到 POJO
      if (request.getScore() == null) {
          return Result.fail("成绩不能为空");
      }
      // 业务逻辑
  }
  ```
- **关键点**：  
  - 字段名必须与表单键名完全一致。  
  - 无需使用 `@RequestParam` 或 `@ModelAttribute`。

---

### **POJO 类设计规范**

1. **强制使用包装类**  
   - **正确**：`private Integer scId;`  
   - **错误**：`private int scId;`（基本类型无法处理 `null`）。

2. **字段名严格一致**  
   - 前后端字段名必须完全一致（包括大小写），例如：  
     - 前端传 `scId=1` → 后端字段名必须为 `scId`（非 `scid` 或 `schoolId`）。  
     - 前端传 `pClass=高三二班` → 后端字段名为 `pClass`（避免关键字冲突）。

3. **扩展性设计**  
   - **继承扩展**：  
     ```java
     public class BaseRequest {
         private Integer id;
         private String name;
     }
     
     public class ExtendedRequest extends BaseRequest {
         private String venue;  // 新增字段
     }
     ```
   - **组合扩展**：  
     ```java
     public class ComplexRequest {
         private SportGroupAddRequest sportGroup;  // 复用已有POJO
         private List<PlayerRequest> players;      // 嵌套其他POJO
     }
     ```
     
---
### Lombok 注解说明

1. **`@Data`**  
   自动生成 Getter、Setter、`toString`、`equals` 和 `hashCode` 方法，省去手写麻烦。  

2. **`@NoArgsConstructor`**  
   生成无参构造方法，Spring 等框架用它创建对象。  

3. **`@AllArgsConstructor`**  
   生成包含所有字段的构造方法，方便快速初始化数据。  

**规则**：要么加这三个注解，要么手动写这些方法，二选一。  

**示例**：  
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private Integer id;  
    private String name;
}
```  
等价于手动写 Getter/Setter、无参构造、全参构造、`toString` 等方法。


---

### **总结总体开发原则**

1. **注解使用优先级**  
   - `@RequestBody`：仅用于 `application/json` 格式。  
   - `@ModelAttribute`：仅用于 `multipart/form-data` 格式。  
   - **其他请求方式（GET、x-www-form-urlencoded）**：直接绑定到 POJO，无需注解。

2. **字段命名与类型**  
   - 严格一致，使用包装类，避免空指针。  
   - 文件字段类型为 `MultipartFile`，需结合 `@ModelAttribute`。

3. **扩展性与维护性**  
   - 通过继承或组合扩展 POJO，适应业务变化。  
   - 统一异常处理，返回标准错误响应。